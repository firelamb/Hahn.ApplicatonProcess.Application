define(["require", "exports", "aurelia-dependency-injection", "./validation-controller", "./validate-trigger", "./get-target-dom-element", "./property-info"], function (require, exports, aurelia_dependency_injection_1, validation_controller_1, validate_trigger_1, get_target_dom_element_1, property_info_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Binding behavior. Indicates the bound property should be validated.
     */
    var ValidateBindingBehaviorBase = /** @class */ (function () {
        function ValidateBindingBehaviorBase(taskQueue) {
            this.taskQueue = taskQueue;
        }
        ValidateBindingBehaviorBase.prototype.bind = function (binding, source, rulesOrController, rules) {
            var _this = this;
            // identify the target element.
            var target = get_target_dom_element_1.getTargetDOMElement(binding, source);
            // locate the controller.
            var controller;
            if (rulesOrController instanceof validation_controller_1.ValidationController) {
                controller = rulesOrController;
            }
            else {
                controller = source.container.get(aurelia_dependency_injection_1.Optional.of(validation_controller_1.ValidationController));
                rules = rulesOrController;
            }
            if (controller === null) {
                throw new Error("A ValidationController has not been registered.");
            }
            controller.registerBinding(binding, target, rules);
            binding.validationController = controller;
            var trigger = this.getValidateTrigger(controller);
            var event = (trigger & validate_trigger_1.validateTrigger.blur) === validate_trigger_1.validateTrigger.blur ? 'blur'
                : (trigger & validate_trigger_1.validateTrigger.focusout) === validate_trigger_1.validateTrigger.focusout ? 'focusout'
                    : null;
            var hasChangeTrigger = (trigger & validate_trigger_1.validateTrigger.change) === validate_trigger_1.validateTrigger.change;
            binding.isDirty = !hasChangeTrigger;
            // validatedOnce is used to control whether controller should validate upon user input
            //
            // always true when validation trigger doesn't include "blur" event (blur/focusout)
            // else it will be set to true after (a) the first user input & loss of focus or (b) validation
            binding.validatedOnce = hasChangeTrigger && event === null;
            if (hasChangeTrigger) {
                binding.vbbUpdateSource = binding.updateSource;
                // tslint:disable-next-line:only-arrow-functions
                // tslint:disable-next-line:space-before-function-paren
                binding.updateSource = function (value) {
                    this.vbbUpdateSource(value);
                    this.isDirty = true;
                    if (this.validatedOnce) {
                        this.validationController.validateBinding(this);
                    }
                };
            }
            if (event !== null) {
                binding.focusLossHandler = function () {
                    _this.taskQueue.queueMicroTask(function () {
                        if (binding.isDirty) {
                            controller.validateBinding(binding);
                            binding.validatedOnce = true;
                        }
                    });
                };
                binding.validationTriggerEvent = event;
                binding.validateTarget = target;
                target.addEventListener(event, binding.focusLossHandler);
                if (hasChangeTrigger) {
                    var propertyName_1 = property_info_1.getPropertyInfo(binding.sourceExpression, binding.source).propertyName;
                    binding.validationSubscription = controller.subscribe(function (event) {
                        if (!binding.validatedOnce && event.type === 'validate') {
                            binding.validatedOnce = event.errors.findIndex(function (e) { return e.propertyName === propertyName_1; }) > -1;
                        }
                    });
                }
            }
            if (trigger !== validate_trigger_1.validateTrigger.manual) {
                binding.standardUpdateTarget = binding.updateTarget;
                // tslint:disable-next-line:only-arrow-functions
                // tslint:disable-next-line:space-before-function-paren
                binding.updateTarget = function (value) {
                    this.standardUpdateTarget(value);
                    this.validationController.resetBinding(this);
                };
            }
        };
        ValidateBindingBehaviorBase.prototype.unbind = function (binding) {
            // reset the binding to it's original state.
            if (binding.vbbUpdateSource) {
                binding.updateSource = binding.vbbUpdateSource;
                binding.vbbUpdateSource = null;
            }
            if (binding.standardUpdateTarget) {
                binding.updateTarget = binding.standardUpdateTarget;
                binding.standardUpdateTarget = null;
            }
            if (binding.focusLossHandler) {
                binding.validateTarget.removeEventListener(binding.validationTriggerEvent, binding.focusLossHandler);
                binding.focusLossHandler = null;
                binding.validateTarget = null;
            }
            if (binding.validationSubscription) {
                binding.validationSubscription.dispose();
                binding.validationSubscription = null;
            }
            binding.validationController.unregisterBinding(binding);
            binding.validationController = null;
            binding.isDirty = null;
            binding.validatedOnce = null;
        };
        return ValidateBindingBehaviorBase;
    }());
    exports.ValidateBindingBehaviorBase = ValidateBindingBehaviorBase;
});
