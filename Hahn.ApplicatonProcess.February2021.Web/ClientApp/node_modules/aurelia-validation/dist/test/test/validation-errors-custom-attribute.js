define(["require", "exports", "aurelia-testing", "aurelia-bootstrapper", "./shared", "../src/aurelia-validation"], function (require, exports, aurelia_testing_1, aurelia_bootstrapper_1, shared_1, aurelia_validation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('ValidationErrorsCustomAttribute', function () {
        var component;
        var viewModel;
        var parentViewModel = { form: '', controller: function () { return null; }, theController: null };
        var container;
        var stageTest = function (validationErrors, supplyControllerToViewModel) {
            var form = "\n      <template>\n        <form novalidate autocomplete='off' " + validationErrors + ">\n          <input ref='standardInput' type='text' value.bind='standardProp & validateOnBlur'>\n        </form>\n      </template>";
            parentViewModel.form = form;
            component = aurelia_testing_1.StageComponent
                .withResources()
                // tslint:disable-next-line:max-line-length
                .inView("<compose containerless view-model=\"./dist/test/test/resources/validation-errors-form-one\" model.bind=\"{ form: form, controller: controller }\"></compose>")
                // tslint:enable-next-line:max-line-length
                .boundTo(parentViewModel);
            var myConfigure = function (aurelia) {
                var config = shared_1.configure(aurelia);
                container = aurelia.container;
                return config;
            };
            component.bootstrap(myConfigure);
            /*
              at this point validation plugin has not yet been initialized, not until in component.create()
            */
            if (supplyControllerToViewModel) {
                /*
                  the viewmodel is going to call this in created().
                  at that point the validation plugin will have been initialized and bind() will
                  not yet have been executed.
                */
                parentViewModel.controller = function () {
                    var factory = container.get(aurelia_validation_1.ValidationControllerFactory);
                    var controller = factory.createForCurrentScope();
                    parentViewModel.theController = controller;
                    return controller;
                };
            }
            return component.create(aurelia_bootstrapper_1.bootstrap)
                .then(function () {
                // we get here after the viewmodel's bind().
                viewModel = component.viewModel.currentViewModel;
            });
        };
        it('sets errors given as default property', function (done) {
            stageTest("validation-errors.bind='myErrors'")
                .then(function () { return expect(viewModel).not.toBeNull(); })
                .then(function () { return expect(viewModel.myErrors instanceof Array).toBe(true); })
                .then(function () { return expect(viewModel.myErrors.length).toBe(0); })
                .then(function () {
                shared_1.blur(viewModel.standardInput);
                return new Promise(function (resolve) { setTimeout(function () { resolve(); }, 0); });
            })
                .then(function () { return expect(viewModel.myErrors.length).toBe(1); })
                .then(done)
                /* tslint:disable:no-console */
                .catch(function (e) { console.log(e.toString()); done(); });
            /* tslint:enable:no-console */
        });
        it('sets errors given as named property', function (done) {
            stageTest("validation-errors='errors.bind:myErrors'")
                .then(function () { return expect(viewModel).not.toBeNull(); })
                .then(function () { return expect(viewModel.myErrors instanceof Array).toBe(true); })
                .then(function () { return expect(viewModel.myErrors.length).toBe(0); })
                .then(function () {
                shared_1.blur(viewModel.standardInput);
                return new Promise(function (resolve) { setTimeout(function () { resolve(); }, 0); });
            })
                .then(function () { return expect(viewModel.myErrors.length).toBe(1); })
                .then(done)
                /* tslint:disable:no-console */
                .catch(function (e) { console.log(e.toString()); done(); });
            /* tslint:enable:no-console */
        });
        it('uses given controller', function (done) {
            stageTest("validation-errors='errors.bind:myErrors;controller.bind:controller'", true)
                .then(function () { return expect(viewModel).not.toBeNull(); })
                .then(function () { return expect(parentViewModel.controller).not.toBeNull(); })
                .then(function () { return expect(viewModel.myErrors instanceof Array).toBe(true); })
                .then(function () { return expect(viewModel.myErrors.length).toBe(0); })
                .then(function () {
                shared_1.blur(viewModel.standardInput);
                return new Promise(function (resolve) { setTimeout(function () { resolve(); }, 0); });
            })
                .then(function () { return expect(viewModel.myErrors.length).toBe(1); })
                // this shows that myErrors is being written from the controller that we gave to validation-errors
                .then(function () { return expect(viewModel.myErrors[0].error).toEqual(parentViewModel.theController.errors[0]); })
                .then(done)
                // tslint:disable-next-line:no-console
                .catch(function (e) { console.log(e.toString()); done(); });
        });
        it('does nothing when given only a controller', function (done) {
            stageTest("validation-errors='controller.bind:controller'", true)
                .then(function () { return expect(viewModel).not.toBeNull(); })
                .then(function () { return expect(parentViewModel.controller).not.toBeNull(); })
                .then(function () { return expect(viewModel.myErrors).toBeUndefined(); })
                .then(function () {
                shared_1.blur(viewModel.standardInput);
                return new Promise(function (resolve) { setTimeout(function () { resolve(); }, 0); });
            })
                .then(function () { return expect(viewModel.myErrors).toBeUndefined(); })
                .then(done)
                // tslint:disable-next-line:no-console
                .catch(function (e) { console.log(e.toString()); done(); });
        });
        it('does nothing when given nothing', function (done) {
            stageTest("validation-errors=''", true)
                .then(function () { return expect(viewModel).not.toBeNull(); })
                .then(function () { return expect(parentViewModel.controller).not.toBeNull(); })
                .then(function () { return expect(viewModel.myErrors).toBeUndefined(); })
                .then(function () {
                shared_1.blur(viewModel.standardInput);
                return new Promise(function (resolve) { setTimeout(function () { resolve(); }, 0); });
            })
                .then(function () { return expect(viewModel.myErrors).toBeUndefined(); })
                .then(done)
                // tslint:disable-next-line:no-console
                .catch(function (e) { console.log(e.toString()); done(); });
        });
        afterEach(function () {
            if (component) {
                component.dispose();
            }
        });
    });
});
